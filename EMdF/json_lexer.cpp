/* Generated by re2c 0.14.3 on Fri Jun  8 17:22:22 2018 */
#line 1 "./json.re"
/*
 * json.re
 *
 * JSON Lexer based on re2c
 *
 * Ulrik Sandborg-Petersen
 * Created: 7/28-2008
 * Last update: 6/8-2018
 *
 */
/************************************************************************
 *
 *   Emdros - the database engine for analyzed or annotated text
 *   Copyright (C) 2008-2018  Ulrik Sandborg-Petersen
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License as
 *   published by the Free Software Foundation, license version 2.  
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *   02111-1307 USA
 *
 *
 *   Special exception
 *   =================
 * 
 *   In addition, as a special exception, Ulrik Petersen, the
 *   copyright holder of Emdros, gives permission to link Emdros, in
 *   whole or in part, with the libraries which are normally
 *   distributed with:
 *   
 *   a) Sun's Java platform,
 *   b) Python, 
 *   c) Jython,
 *   d) Ruby, and/or 
 *   e) Perl 
 *   f) PostgreSQL
 *   g) OpenSSL
 *
 *   (or with modified versions of these), and to distribute linked
 *   combinations including both Emdros, in whole or in part, and one
 *   or more of the libraries normally distributed with (a)-(g) above.
 *
 *   Please note: This gives you special rights concerning the
 *   libraries which normally accompany the above pieces of software.
 *   It gives you no special rights concerning software that you write
 *   yourself.  You must obey the GNU General Public License in all
 *   respects for all of the code used other than the libraries
 *   normally distributed with (a)-(g) above.
 *
 *   If you modify this file, you may extend this exception to your
 *   version of the file, but you are not obligated to do so. If you
 *   do not wish to do so, delete this exception statement from your
 *   version.
 *
 *
 *   Other licensing forms
 *   =====================
 *
 *   If you wish to negotiate commercial licensing, please contact
 *   Ulrik Petersen at ulrikp[at]users.sourceforge.net.
 *
 *   Licensing can also be negotiated if your organization is an
 *   educational, non-profit, charity, missionary or similar
 *   organization.
 *
 *
 *   Website
 *   =======
 *
 *   Emdros has a website here:
 *
 *   http://emdros.org
 *
 *
 *
 **************************************************************************/

#include <json_lexer.h>
#include "jsonpars.h"
#include <iostream>
#include <string_func.h>

#define YYCTYPE         unsigned char
#define YYCURSOR        cur
#define YYLIMIT         lim
#define YYMARKER        ptr
#line 98 "./json.re"



#line 133 "./json.re"



JSONScanner::JSONScanner(const std::string& strIn)
{
	m_szIn = strIn;
	sz = m_szIn.c_str();
	lim = sz + strIn.length();
	bot = tok = ptr = pos = top = eof = 0;
	cur = sz;
	m_pOpenBrace = newToken();
	m_pCloseBrace = newToken();
	m_pOpenBracket = newToken();
	m_pCloseBracket = newToken();
	m_pTrue = newToken();
	m_pFalse = newToken();
	m_pNull = newToken();
	m_pComma = newToken();
	m_pColon = newToken();
	m_pOpenBrace->setName("{");
	m_pCloseBrace->setName("}");
	m_pOpenBracket->setName("[");
	m_pCloseBracket->setName("]");
	m_pTrue->setName("true");
	m_pFalse->setName("false");
	m_pNull->setName("null");
	m_pComma->setName(",");
	m_pColon->setName(":");
}

JSONScanner::~JSONScanner()
{
	if (bot) {
		delete[] bot;
	}
	delete(m_pOpenBrace);
	delete(m_pCloseBrace);
	delete(m_pOpenBracket);
	delete(m_pCloseBracket);
	delete(m_pTrue);
	delete(m_pFalse);
	delete(m_pNull);
	delete(m_pComma);
	delete(m_pColon);

}
bool JSONScanner::isLocallyAllocatedToken(Token *pToken)
{
	return pToken == m_pOpenBrace
	|| pToken == m_pCloseBrace
	|| pToken == m_pOpenBracket
	|| pToken == m_pCloseBracket
	|| pToken == m_pTrue
	|| pToken == m_pFalse
	|| pToken == m_pNull
	|| pToken == m_pComma
	|| pToken == m_pColon;
}


#define TOKEN_RETURN(X,Y) { (*yylval)->setName(X); return Y; }
#define LOCAL_TOKEN_RETURN(L,Y) { *yylval = L; return Y; }
#define NEW_TOKEN() { (*yylval) = newToken(); }
#define NEW_TOKEN_RETURN(X,Y) { NEW_TOKEN() TOKEN_RETURN(X,Y) }



int JSONScanner::scan(Token **ppYYLVAL)
{
	yylval = ppYYLVAL;

 scan:	
	tok = cur;


#line 178 "./json_lexer.cpp"
{
	YYCTYPE yych;

	yych = *YYCURSOR;
	if (yych <= 'F') {
		if (yych <= '!') {
			if (yych <= '\n') {
				if (yych <= 0x00) goto jj31;
				if (yych <= 0x08) goto jj33;
				if (yych <= '\t') goto jj25;
				goto jj29;
			} else {
				if (yych <= '\r') {
					if (yych <= '\f') goto jj33;
					goto jj27;
				} else {
					if (yych == ' ') goto jj23;
					goto jj33;
				}
			}
		} else {
			if (yych <= '-') {
				if (yych <= '"') goto jj21;
				if (yych <= '+') goto jj33;
				if (yych <= ',') goto jj16;
				goto jj18;
			} else {
				if (yych <= '9') {
					if (yych <= '/') goto jj33;
					goto jj19;
				} else {
					if (yych <= ':') goto jj14;
					if (yych <= 'E') goto jj33;
				}
			}
		}
	} else {
		if (yych <= 'e') {
			if (yych <= 'T') {
				if (yych == 'N') goto jj5;
				if (yych <= 'S') goto jj33;
				goto jj4;
			} else {
				if (yych <= '[') {
					if (yych <= 'Z') goto jj33;
					goto jj10;
				} else {
					if (yych == ']') goto jj12;
					goto jj33;
				}
			}
		} else {
			if (yych <= 't') {
				if (yych <= 'm') {
					if (yych >= 'g') goto jj33;
				} else {
					if (yych <= 'n') goto jj5;
					if (yych <= 's') goto jj33;
					goto jj4;
				}
			} else {
				if (yych <= '{') {
					if (yych <= 'z') goto jj33;
					goto jj6;
				} else {
					if (yych == '}') goto jj8;
					goto jj33;
				}
			}
		}
	}
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'A') goto jj63;
	if (yych == 'a') goto jj63;
jj3:
#line 231 "./json.re"
	{ goto end; /* anything else is an error, so return EOF. */ }
#line 256 "./json_lexer.cpp"
jj4:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'R') goto jj59;
	if (yych == 'r') goto jj59;
	goto jj3;
jj5:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'U') goto jj54;
	if (yych == 'u') goto jj54;
	goto jj3;
jj6:
	++YYCURSOR;
#line 211 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pOpenBrace, T_JSON_KEY_BRACE_OPEN); }
#line 271 "./json_lexer.cpp"
jj8:
	++YYCURSOR;
#line 212 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pCloseBrace,T_JSON_KEY_BRACE_CLOSE); }
#line 276 "./json_lexer.cpp"
jj10:
	++YYCURSOR;
#line 213 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pOpenBracket, T_JSON_KEY_BRACKET_OPEN); }
#line 281 "./json_lexer.cpp"
jj12:
	++YYCURSOR;
#line 214 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pCloseBracket, T_JSON_KEY_BRACKET_CLOSE); }
#line 286 "./json_lexer.cpp"
jj14:
	++YYCURSOR;
#line 215 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pColon, T_JSON_KEY_COLON);  }
#line 291 "./json_lexer.cpp"
jj16:
	++YYCURSOR;
#line 216 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pComma, T_JSON_KEY_COMMA); }
#line 296 "./json_lexer.cpp"
jj18:
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj3;
	if (yych <= '9') goto jj53;
	goto jj3;
jj19:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '/') goto jj20;
	if (yych <= '9') goto jj34;
jj20:
#line 217 "./json.re"
	{ NEW_TOKEN(); 
                                  addInteger();
                                  TOKEN_RETURN(INTEGER_MAGIC, T_JSON_INTEGER); }
#line 311 "./json_lexer.cpp"
jj21:
	++YYCURSOR;
#line 220 "./json.re"
	{ 
                              NEW_TOKEN(); 
                              (*yylval)->setString(new std::string);
			      (*yylval)->pString->reserve(32);
			      goto stringdq; 
                            }
#line 321 "./json_lexer.cpp"
jj23:
	++YYCURSOR;
#line 226 "./json.re"
	{ goto scan; }
#line 326 "./json_lexer.cpp"
jj25:
	++YYCURSOR;
#line 227 "./json.re"
	{ goto scan; }
#line 331 "./json_lexer.cpp"
jj27:
	++YYCURSOR;
#line 228 "./json.re"
	{ goto scan; }
#line 336 "./json_lexer.cpp"
jj29:
	++YYCURSOR;
#line 229 "./json.re"
	{ goto scan; }
#line 341 "./json_lexer.cpp"
jj31:
	++YYCURSOR;
#line 230 "./json.re"
	{ if (cur >= lim) { goto end; } }
#line 346 "./json_lexer.cpp"
jj33:
	yych = *++YYCURSOR;
	goto jj3;
jj34:
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych >= ':') goto jj20;
	yych = *++YYCURSOR;
	goto jj20;
jj53:
	yych = *++YYCURSOR;
	if (yych <= '/') goto jj20;
	if (yych <= '9') goto jj34;
	goto jj20;
jj54:
	yych = *++YYCURSOR;
	if (yych == 'L') goto jj56;
	if (yych == 'l') goto jj56;
jj55:
	YYCURSOR = YYMARKER;
	goto jj3;
jj56:
	yych = *++YYCURSOR;
	if (yych == 'L') goto jj57;
	if (yych != 'l') goto jj55;
jj57:
	++YYCURSOR;
#line 210 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pNull, T_JSON_KEY_NULL); }
#line 427 "./json_lexer.cpp"
jj59:
	yych = *++YYCURSOR;
	if (yych == 'U') goto jj60;
	if (yych != 'u') goto jj55;
jj60:
	yych = *++YYCURSOR;
	if (yych == 'E') goto jj61;
	if (yych != 'e') goto jj55;
jj61:
	++YYCURSOR;
#line 209 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pTrue, T_JSON_KEY_TRUE); }
#line 440 "./json_lexer.cpp"
jj63:
	yych = *++YYCURSOR;
	if (yych == 'L') goto jj64;
	if (yych != 'l') goto jj55;
jj64:
	yych = *++YYCURSOR;
	if (yych == 'S') goto jj65;
	if (yych != 's') goto jj55;
jj65:
	yych = *++YYCURSOR;
	if (yych == 'E') goto jj66;
	if (yych != 'e') goto jj55;
jj66:
	++YYCURSOR;
#line 208 "./json.re"
	{ LOCAL_TOKEN_RETURN(m_pFalse, T_JSON_KEY_FALSE); }
#line 457 "./json_lexer.cpp"
}
#line 232 "./json.re"


stringdq:
	tok = cur;

#line 465 "./json_lexer.cpp"
{
	YYCTYPE yych;
	yych = *YYCURSOR;
	if (yych <= '!') {
		if (yych <= 0x00) goto jj74;
		if (yych == '\n') goto jj77;
		goto jj76;
	} else {
		if (yych <= '"') goto jj70;
		if (yych == '\\') goto jj72;
		goto jj76;
	}
jj70:
	++YYCURSOR;
#line 237 "./json.re"
	{ TOKEN_RETURN(STRING_MAGIC, T_JSON_STRING); }
#line 482 "./json_lexer.cpp"
jj72:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'b') {
		if (yych <= '&') {
			if (yych <= '\f') {
				if (yych == '\n') goto jj85;
			} else {
				if (yych <= '\r') goto jj83;
				if (yych == '"') goto jj87;
			}
		} else {
			if (yych <= '?') {
				if (yych <= '\'') goto jj89;
				if (yych >= '?') goto jj91;
			} else {
				if (yych == '\\') goto jj93;
				if (yych >= 'b') goto jj99;
			}
		}
	} else {
		if (yych <= 's') {
			if (yych <= 'm') {
				if (yych == 'f') goto jj95;
			} else {
				if (yych <= 'n') goto jj103;
				if (yych == 'r') goto jj97;
			}
		} else {
			if (yych <= 'w') {
				if (yych <= 't') goto jj101;
				if (yych <= 'u') goto jj79;
			} else {
				if (yych <= 'x') goto jj81;
				if (yych == 0xE2) goto jj82;
			}
		}
	}
jj73:
#line 268 "./json.re"
	{ (*yylval)->pString->push_back(*tok);
			       goto stringdq; }
#line 524 "./json_lexer.cpp"
jj74:
	++YYCURSOR;
#line 267 "./json.re"
	{ if (cur >= lim) { goto end; } /* We might encounter a string which does not end before EOF. */ }
#line 529 "./json_lexer.cpp"
jj76:
	yych = *++YYCURSOR;
	goto jj73;
jj77:
	++YYCURSOR;
#line 270 "./json.re"
	{ (*yylval)->pString->push_back('\n');
			       goto stringdq; }
#line 538 "./json_lexer.cpp"
jj79:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto jj80;
		if (yych <= '9') goto jj115;
	} else {
		if (yych <= 'F') goto jj115;
		if (yych <= '`') goto jj80;
		if (yych <= 'f') goto jj115;
	}
jj80:
	YYCURSOR = YYMARKER;
	goto jj73;
jj81:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto jj80;
		if (yych <= '9') goto jj112;
		goto jj80;
	} else {
		if (yych <= 'F') goto jj112;
		if (yych <= '`') goto jj80;
		if (yych <= 'f') goto jj112;
		goto jj80;
	}
jj82:
	yych = *++YYCURSOR;
	if (yych == 0x80) goto jj107;
	goto jj80;
jj83:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '\n') goto jj105;
#line 249 "./json.re"
	{ /* eaten; it is a LineContinuation */ goto stringdq; }
#line 573 "./json_lexer.cpp"
jj85:
	++YYCURSOR;
#line 247 "./json.re"
	{ /* eaten; it is a LineContinuation */ goto stringdq; }
#line 578 "./json_lexer.cpp"
jj87:
	++YYCURSOR;
#line 246 "./json.re"
	{ (*yylval)->pString->push_back('\"'); goto stringdq; }
#line 583 "./json_lexer.cpp"
jj89:
	++YYCURSOR;
#line 245 "./json.re"
	{ (*yylval)->pString->push_back('\''); goto stringdq; }
#line 588 "./json_lexer.cpp"
jj91:
	++YYCURSOR;
#line 244 "./json.re"
	{ (*yylval)->pString->push_back('\?'); goto stringdq; }
#line 593 "./json_lexer.cpp"
jj93:
	++YYCURSOR;
#line 243 "./json.re"
	{ (*yylval)->pString->push_back('\\'); goto stringdq; }
#line 598 "./json_lexer.cpp"
jj95:
	++YYCURSOR;
#line 242 "./json.re"
	{ (*yylval)->pString->push_back('\f'); goto stringdq; }
#line 603 "./json_lexer.cpp"
jj97:
	++YYCURSOR;
#line 241 "./json.re"
	{ (*yylval)->pString->push_back('\r'); goto stringdq; }
#line 608 "./json_lexer.cpp"
jj99:
	++YYCURSOR;
#line 240 "./json.re"
	{ (*yylval)->pString->push_back('\b'); goto stringdq; }
#line 613 "./json_lexer.cpp"
jj101:
	++YYCURSOR;
#line 239 "./json.re"
	{ (*yylval)->pString->push_back('\t'); goto stringdq; }
#line 618 "./json_lexer.cpp"
jj103:
	++YYCURSOR;
#line 238 "./json.re"
	{ (*yylval)->pString->push_back('\n'); goto stringdq; }
#line 623 "./json_lexer.cpp"
jj105:
	++YYCURSOR;
#line 248 "./json.re"
	{ /* eaten; it is a LineContinuation */ goto stringdq; }
#line 628 "./json_lexer.cpp"
jj107:
	yych = *++YYCURSOR;
	if (yych <= 0xA7) goto jj80;
	if (yych <= 0xA8) goto jj110;
	if (yych >= 0xAA) goto jj80;
	++YYCURSOR;
#line 251 "./json.re"
	{ /* \\ + \u2029 (<PS>) is eaten; it is a LineContinuation */ goto stringdq; }
#line 637 "./json_lexer.cpp"
jj110:
	++YYCURSOR;
#line 250 "./json.re"
	{ /* \\ + \u2028 (<LS>) is eaten; it is a LineContinuation */ goto stringdq; }
#line 642 "./json_lexer.cpp"
jj112:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto jj80;
		if (yych >= ':') goto jj80;
	} else {
		if (yych <= 'F') goto jj113;
		if (yych <= '`') goto jj80;
		if (yych >= 'g') goto jj80;
	}
jj113:
	++YYCURSOR;
#line 252 "./json.re"
	{ tok += 2; // Go past SLASH x
			       std::string mystr;
			       getString(mystr);
			       (*yylval)->pString->push_back(hex2char(mystr.c_str()));
			       goto stringdq; 			     
                             }
#line 662 "./json_lexer.cpp"
jj115:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto jj80;
		if (yych >= ':') goto jj80;
	} else {
		if (yych <= 'F') goto jj116;
		if (yych <= '`') goto jj80;
		if (yych >= 'g') goto jj80;
	}
jj116:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto jj80;
		if (yych >= ':') goto jj80;
	} else {
		if (yych <= 'F') goto jj117;
		if (yych <= '`') goto jj80;
		if (yych >= 'g') goto jj80;
	}
jj117:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto jj80;
		if (yych >= ':') goto jj80;
	} else {
		if (yych <= 'F') goto jj118;
		if (yych <= '`') goto jj80;
		if (yych >= 'g') goto jj80;
	}
jj118:
	++YYCURSOR;
#line 258 "./json.re"
	{ tok += 2; // Go past SLASH x
			       std::string mystr;
			       getString(mystr);
			       long hex_long = hex2long(mystr);
			       std::string utf8_output;
			       long2utf8(hex_long, utf8_output);
			       (*(*yylval)->pString) += utf8_output;
			       goto stringdq; 			     
                             }
#line 705 "./json_lexer.cpp"
}
#line 272 "./json.re"


 end:
	return 0;
}


void JSONScanner::addToken(void)
{
	(*yylval)->setString(new std::string);
	std::string::size_type length = cur - tok;
	(*yylval)->pString->reserve(length);
	(*yylval)->pString->append(tok, length);
/*
	const char *p;
	for (p = tok;
	     p != cur;
	     ++p) {
	     (*yylval)->pString->push_back(*p);
	}
*/
}

void JSONScanner::addInteger(void)
{
	const unsigned int MAX_INTEGER_CHARS = 20;
	unsigned int cnt = cur - tok;
	if (cnt > MAX_INTEGER_CHARS) {
	   	std::string mystring;
		const char *p;
		for (p = tok;
		     p != cur;
	     	     ++p) {
		     mystring.append(1, *p);
		}
		(*yylval)->setInteger(sz2emdros_int64(mystring.c_str()));
        } else {
		char szInt[MAX_INTEGER_CHARS+1];

		const char *p;
		char *q = szInt;
		for (p = tok;
		     p != cur;
	     	     ++p) {
		     *q++ = *p;
		}
		*q = '\0';
		(*yylval)->setInteger(sz2emdros_int64(szInt));
	}
}

void JSONScanner::getString(std::string& str)
{
	std::string::size_type length = cur - tok;
	str.reserve(length);
	str.append(tok, length);
/*
	const char *p;
	for (p = tok;
	     p != cur;
	     ++p) {
	     str.append(1, *p);
	}
*/
}

std::string JSONScanner::getInputScannedSoFar()
{
	if (cur == 0 || sz == 0) {
	        return "";
        } else {
                long length = cur - sz;
	        if (length < 0) {
	              return "";
            	} else {
	              std::string result;
		      for (const char *p = sz;
		           p != cur;
		           ++p) {
		              result += *p;
		      } 
		      return result;
                }
        }
}
