/* Generated by re2c 0.14.3 on Fri Jun  8 18:26:45 2018 */
#line 1 "pennlexer.re"
/*
 * pennlexer.lxx
 *
 * Penn Treebank lexer
 *
 * Ulrik Petersen
 * Created: 2/17-2006
 * Last update: 6/17-2011
 *
 */
/************************************************************************
 *
 *   Emdros - the database engine for analyzed or annotated text
 *   Copyright (C) 2006-2011  Ulrik Sandborg-Petersen
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License as
 *   published by the Free Software Foundation, license version 2.  
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *   02111-1307 USA
 *
 *
 *   Special exception
 *   =================
 * 
 *   In addition, as a special exception, Ulrik Petersen, the
 *   copyright holder of Emdros, gives permission to link Emdros, in
 *   whole or in part, with the libraries which are normally
 *   distributed with:
 *   
 *   a) Sun's Java platform,
 *   b) Python, 
 *   c) Jython,
 *   d) Ruby, and/or 
 *   e) Perl 
 *   f) PostgreSQL
 *   g) OpenSSL
 *
 *   (or with modified versions of these), and to distribute linked
 *   combinations including both Emdros, in whole or in part, and one
 *   or more of the libraries normally distributed with (a)-(g) above.
 *
 *   Please note: This gives you special rights concerning the
 *   libraries which normally accompany the above pieces of software.
 *   It gives you no special rights concerning software that you write
 *   yourself.  You must obey the GNU General Public License in all
 *   respects for all of the code used other than the libraries
 *   normally distributed with (a)-(g) above.
 *
 *   If you modify this file, you may extend this exception to your
 *   version of the file, but you are not obligated to do so. If you
 *   do not wish to do so, delete this exception statement from your
 *   version.
 *
 *
 *   Other licensing forms
 *   =====================
 *
 *   If you wish to negotiate commercial licensing, please contact
 *   Ulrik Petersen at ulrikp[at]users.sourceforge.net.
 *
 *   Licensing can also be negotiated if your organization is an
 *   educational, non-profit, charity, missionary or similar
 *   organization.
 *
 *
 *   Website
 *   =======
 *
 *   Emdros has a website here:
 *
 *   http://emdros.org
 *
 *
 *
 **************************************************************************/



#include <string>
#include <sstream>
#include <pennimporter.h>
#include "pennparser.h"

#define TOKEN_RETURN(X,Y) { yylval->setName(X); /* std::cerr << "UP200: TOKEN_NAME = " << #X << ", token = " << Y << std::endl; */ return Y; }

#define YYMAXFILL 4


#define BSIZE 8192
#if YYMAXFILL > BSIZE
#error YYMAXFILL must be less than or equal to BSIZE!
#endif

#define YYCTYPE         unsigned char
#define YYCURSOR        cur
#define YYLIMIT         lim
#define YYMARKER        ptr
#define YYFILL(n)       {cur = fill(cur);}

#line 118 "pennlexer.re"


PennScanner::PennScanner(std::istream *pIstr)
{
	pIn = pIstr;
	bot = tok = ptr = cur = pos = lim = top = eof = 0;
}

PennScanner::~PennScanner()
{
	if (bot) {
		delete[] bot;
	}
}

void PennScanner::addToken(void)
{
	yylval->setString(new std::string);
	const unsigned char *p;
	for (p = tok;
	     p != cur;
	     ++p) {
	     yylval->pString->append(1, *p);
	}
	// std::cerr << "UP202: addToken: '" << *(yylval->pString) << "'" << std::endl;
}

unsigned char *PennScanner::fill(unsigned char *cursor)
{
        if(!eof)
        {
                unsigned int cnt = tok - bot;
                if(cnt)
                {
                        memcpy(bot, tok, lim - tok);
                        tok = bot;
                        ptr -= cnt;
                        cursor -= cnt;
                        pos -= cnt;
                        lim -= cnt;
                }
                if((top - lim) < BSIZE)
                {
                        unsigned char *buf = new unsigned char[(lim - bot) + BSIZE];
                        memcpy(buf, tok, lim - tok);
                        tok = buf;
                        ptr = &buf[ptr - bot];
                        cursor = &buf[cursor - bot];
                        pos = &buf[pos - bot];
                        lim = &buf[lim - bot];
                        top = &lim[BSIZE];
                        delete [] bot;
                        bot = buf;
                }
                pIn->read((char *) lim, BSIZE);
                if ((cnt = pIn->gcount()) != BSIZE )
                {
                        eof = &lim[cnt]; *eof++ = '\0';
                }
                lim += cnt;
        }
        return cursor;
}


int PennScanner::scan(PennToken *pYYLVAL)
{
	yylval = pYYLVAL;
	

 scan:	
	tok = cur;


#line 187 "pennlexer.cpp"
{
	YYCTYPE yych;

	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
	if (yych <= ' ') {
		if (yych <= '\v') {
			if (yych <= 0x00) goto yy14;
			if (yych <= 0x08) goto yy8;
			if (yych <= '\n') goto yy4;
			goto yy6;
		} else {
			if (yych == '\r') goto yy4;
			if (yych <= 0x1F) goto yy8;
			goto yy4;
		}
	} else {
		if (yych <= '\'') {
			if (yych <= '#') goto yy8;
			if (yych <= '$') goto yy9;
			if (yych >= '&') goto yy8;
		} else {
			if (yych <= ')') {
				if (yych <= '(') goto yy10;
				goto yy12;
			} else {
				if (yych == '[') goto yy7;
				goto yy8;
			}
		}
	}
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '%') goto yy27;
	goto yy18;
yy3:
#line 195 "pennlexer.re"
	{ addToken();
            TOKEN_RETURN("word/function", T_NAME);
          }
#line 227 "pennlexer.cpp"
yy4:
	++YYCURSOR;
yy5:
#line 193 "pennlexer.re"
	{ goto scan; }
#line 233 "pennlexer.cpp"
yy6:
	yych = *++YYCURSOR;
	if (yych <= '\r') {
		if (yych <= 0x08) {
			if (yych <= 0x00) goto yy5;
			goto yy17;
		} else {
			if (yych <= '\n') goto yy5;
			if (yych <= '\f') goto yy17;
			goto yy5;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy17;
			goto yy5;
		} else {
			if (yych <= '\'') goto yy17;
			if (yych <= ')') goto yy5;
			goto yy17;
		}
	}
yy7:
	yych = *++YYCURSOR;
	if (yych == '.') goto yy23;
	if (yych <= '/') goto yy18;
	if (yych <= '9') goto yy23;
	goto yy18;
yy8:
	yych = *++YYCURSOR;
	goto yy18;
yy9:
	yych = *++YYCURSOR;
	if (yych == '(') goto yy16;
	goto yy18;
yy10:
	++YYCURSOR;
#line 198 "pennlexer.re"
	{ TOKEN_RETURN("LPAREN", T_KEY_LPAREN); }
#line 272 "pennlexer.cpp"
yy12:
	++YYCURSOR;
#line 199 "pennlexer.re"
	{ TOKEN_RETURN("RPAREN", T_KEY_RPAREN); }
#line 277 "pennlexer.cpp"
yy14:
	++YYCURSOR;
#line 200 "pennlexer.re"
	{ if (cur >= eof) { goto end; } }
#line 282 "pennlexer.cpp"
yy16:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '-') goto yy19;
	goto yy3;
yy17:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy18:
	if (yych <= '\r') {
		if (yych <= 0x08) {
			if (yych <= 0x00) goto yy3;
			goto yy17;
		} else {
			if (yych <= '\n') goto yy3;
			if (yych <= '\f') goto yy17;
			goto yy3;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy17;
			goto yy3;
		} else {
			if (yych <= '\'') goto yy17;
			if (yych <= ')') goto yy3;
			goto yy17;
		}
	}
yy19:
	yych = *++YYCURSOR;
	if (yych <= '\r') {
		if (yych <= 0x08) {
			if (yych >= 0x01) goto yy21;
		} else {
			if (yych <= '\n') goto yy20;
			if (yych <= '\f') goto yy21;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy21;
		} else {
			if (yych <= '\'') goto yy21;
			if (yych >= '*') goto yy21;
		}
	}
yy20:
	YYCURSOR = YYMARKER;
	goto yy3;
yy21:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '\r') {
		if (yych <= 0x08) {
			if (yych <= 0x00) goto yy3;
			goto yy21;
		} else {
			if (yych <= '\n') goto yy3;
			if (yych <= '\f') goto yy21;
			goto yy3;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy21;
			goto yy3;
		} else {
			if (yych <= '\'') goto yy21;
			if (yych <= ')') goto yy3;
			goto yy21;
		}
	}
yy23:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych <= '\'') {
		if (yych <= '\f') {
			if (yych <= 0x00) goto yy3;
			if (yych <= 0x08) goto yy17;
			if (yych <= '\n') goto yy3;
			goto yy17;
		} else {
			if (yych <= '\r') goto yy3;
			if (yych == ' ') goto yy3;
			goto yy17;
		}
	} else {
		if (yych <= '/') {
			if (yych <= ')') goto yy3;
			if (yych == '.') goto yy23;
			goto yy17;
		} else {
			if (yych <= '9') goto yy23;
			if (yych != ']') goto yy17;
		}
	}
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '\r') {
		if (yych <= 0x08) {
			if (yych >= 0x01) goto yy17;
		} else {
			if (yych <= '\n') goto yy26;
			if (yych <= '\f') goto yy17;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy17;
		} else {
			if (yych <= '\'') goto yy17;
			if (yych >= '*') goto yy17;
		}
	}
yy26:
#line 194 "pennlexer.re"
	{ goto scan; }
#line 398 "pennlexer.cpp"
yy27:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '\r') {
		if (yych <= 0x08) {
			if (yych >= 0x01) goto yy17;
		} else {
			if (yych <= '\n') goto yy28;
			if (yych <= '\f') goto yy17;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy17;
		} else {
			if (yych <= '\'') goto yy17;
			if (yych >= '*') goto yy17;
		}
	}
yy28:
#line 192 "pennlexer.re"
	{ goto comment; }
#line 419 "pennlexer.cpp"
}
#line 202 "pennlexer.re"


 comment:

#line 426 "pennlexer.cpp"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 0x00) goto yy33;
	if (yych != '\n') goto yy35;
	++YYCURSOR;
#line 206 "pennlexer.re"
	{ goto scan; }
#line 436 "pennlexer.cpp"
yy33:
	++YYCURSOR;
#line 207 "pennlexer.re"
	{ if (cur >= eof) { goto end; } }
#line 441 "pennlexer.cpp"
yy35:
	++YYCURSOR;
#line 208 "pennlexer.re"
	{ tok = cur; goto comment; }
#line 446 "pennlexer.cpp"
}
#line 209 "pennlexer.re"


 end:
 	return 0;
}
